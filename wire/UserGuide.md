## Wire用户手册

### 基础知识
Wire有两个核心概念:　提供器（providers）和 注入器（injectors）

#### 定义提供器
Wire的主要机制是提供器，是一个可以产生值的函数，类似下面的代码。
```
package foobarbaz

type Foo struct {
    X int
}

// ProvideFoo returns a Foo.
func ProvideFoo() Foo {
    return Foo{X: 42}
}
```
为了被其他包使用提供器函数必须可以被导出，可以通过参数指定依赖。
```
package foobarbaz
// ....

type Bar struct {
    X int
}

// ProvideBar returns a Bar: a negative Foo.
func ProvideBar(foo Foo) Bar {
    return Bar{X: -foo.X}
}
```
提供器函数可以返回错误。
```
package foobarbaz

import (
    "context"
    "errors"
)

// ...

type Baz struct {
    X int
}

// ProvideBaz returns a value if Bar is not zero.
func ProvideBaz(ctx context.Context, bar Bar) (Baz, error) {
    if bar.X == 0 {
        return Baz{}, errors.New("cannot provide baz when bar is zero")
    }
    return Baz{X: bar.X}, nil
}
```
多个提供器可以被分组管理。如果多个提供器经常一起使用这会非常有用。我们可以使用wire.NewSet函数将这些提供器放置在一起。
```
package foobarbaz

import (
    // ...
    "github.com/google/wire"
)

// ...

var SuperSet = wire.NewSet(ProvideFoo, ProvideBar, ProvideBaz)
```
也可以把一个提供器集合添加到另外一个提供器集合里面。
```
package foobarbaz

import (
    // ...
    "example.com/some/other/pkg"
)
// ...

var MegaSet = wire.NewSet(SuperSet, pkg.OtherSet)
```

#### 注入器
+ 一个程序使用注入器将这些提供器连接起来。通过Wire只需要写注入器的署名然后使用工具生成函数体。
+ 函数体中使用了wire.Build那么他就是一个注入器。返回值只要符合Go标准就好。
```
package main

import (
    "context"

    "github.com/google/wire"
    "example.com/foobarbaz"
)

func initializeBaz(ctx context.Context) (foobarbaz.Baz, error) {
    wire.Build(foobarbaz.MegaSet)
    return foobarbaz.Baz{}, nil
}
```
在当前目录执行wire生成注入器代码。生成的文件名为wire_gen.go，代码类似：
```
// Code generated by Wire. DO NOT EDIT.

//go:generate wire
//+build !wireinject

package main

import (
    "example.com/foobarbaz"
)

func initializeBaz(ctx context.Context) (foobarbaz.Baz, error) {
    foo := foobarbaz.ProvideFoo()
    bar := foobarbaz.ProvideBar(foo)
    baz, err := foobarbaz.ProvideBaz(ctx, bar)
    if err != nil {
        return 0, err
    }
    return baz, nil
}
```
代码和我们写的代码很类似，此外，在运行时几乎不依赖于Wire:所有编写的代码都是普通的Go代码，可以在不使用Wire的情况下使用。只要wire_gen.go生成了，我们就可以使用go generate再次生成。

### 高级特性
#### 绑定接口
通常，依赖项注入用于绑定接口的具体实现。Wire通过类型标识将输入与输出匹配，因此倾向于创建返回接口类型的提供器。然而，这不是惯用的，因为Go的最佳实践是返回具体类型。相反，您可以在提供程序集中声明接口绑定:
```
type Fooer interface {
    Foo() string
}

type MyFooer string

func (b *MyFooer) Foo() string {
    return string(*b)
}

func provideMyFooer() *MyFooer {
    b := new(MyFooer)
    *b = "Hello, World!"
    return b
}

type Bar string

func provideBar(f Fooer) string {
    // f will be a *MyFooer.
    return f.Foo()
}

var Set = wire.NewSet(
    provideMyFooer,
    wire.Bind(new(Fooer), new(*MyFooer)),
    provideBar)
```
wire.Bind的第一个参数是所需的接口类型的指针，第二参数为实现该接口的实例的指针。任何包含接口绑定的集合还必须在提供具体类型的集合中有一个提供程序。

#### Struct Providers
使用wire.Struct函数构造一个结构类型，并告诉注入器应该注入哪个字段。注入器将使用字段类型的提供程序填充每个字段。对于生成的结构类型S，使用wire.Struct同时提供了S和*S。例如，给定以下提供者:
```
type Foo int
type Bar int

func ProvideFoo() Foo {/* ... */}

func ProvideBar() Bar {/* ... */}

type FooBar struct {
    MyFoo Foo
    MyBar Bar
}

var Set = wire.NewSet(
    ProvideFoo,
    ProvideBar,
    wire.Struct(new(FooBar), "MyFoo", "MyBar"))
```
生成的注入器类似：
```
func injectFooBar() FooBar {
    foo := ProvideFoo()
    bar := ProvideBar()
    fooBar := FooBar{
        MyFoo: foo,
        MyBar: bar,
    }
    return fooBar
}
```
wire.Struct第一个参数为需要的数据类型的指针，下面的参数为需要被注入的字段的名字。全部注入使用"*",类似wire.Struct(new(FooBar), "*")。
单纯注入FooBar代码：
```
var Set = wire.NewSet(
    ProvideFoo,
    wire.Struct(new(FooBar), "MyFoo"))
```
有时候为了保护某些字段希望不被注入我们使用如下方式进行
```
type Foo struct {
    mu sync.Mutex `wire:"-"`
    Bar Bar
}
```

#### 绑定值
有时，将基本值(通常为nil)绑定到类型是很有用的。可以向提供程序集添加值表达式，而不是让注入器依赖于一次性提供程序函数。
```
type Foo struct {
    X int
}

func injectFoo() Foo {
    wire.Build(wire.Value(Foo{X: 42}))
    return Foo{}
}
```
生成代码如下：
```
func injectFoo() Foo {
    foo := _wireFooValue
    return foo
}

var (
    _wireFooValue = Foo{X: 42}
)
```
需要注意的是，表达式将被复制到注入器的包中;对变量的引用将在注入器包的初始化过程中进行评估。如果表达式调用任何函数或从任何通道接收，则发出错误。

#### 使用结构体字段作为提供器
有时，用户需要的提供程序是结构体的一些字段。如果你发现自己写了一个提供程序，像下面的例子，以促进结构字段到提供的类型:
```
type Foo struct {
    S string
    N int
    F float64
}

func getS(foo Foo) string {
    // Bad! Use wire.FieldsOf instead.
    return foo.S
}

func provideFoo() Foo {
    return Foo{ S: "Hello, World!", N: 1, F: 3.14 }
}
func injectedMessage() string {
    wire.Build(
        provideFoo,
        wire.FieldsOf(new(Foo), "S"))
    return ""
}
```
#### 清理函数
如果提供器需要清理资源(比如：关闭文件)，然后它可以返回一个闭包来清理资源。注入器将使用它向调用者返回聚合的清理函数，或者在注入器的实现中稍后调用的提供者返回错误时清理资源。
```
func provideFile(log Logger, path Path) (*os.File, func(), error) {
    f, err := os.Open(string(path))
    if err != nil {
        return nil, nil, err
    }
    cleanup := func() {
        if err := f.Close(); err != nil {
            log.Log(err)
        }
    }
    return f, cleanup, nil
}
```
一个清理函数保证在任何提供者的输入的清理函数之前被调用，并且必须具有签名func()。